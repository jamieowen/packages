{"version":3,"file":"item-bc8a12c1.js","sources":["../../../../../node_modules/@thi.ng/shader-ast/ast/checks.js","../../../../../node_modules/@thi.ng/shader-ast/ast/idgen.js","../../../../../node_modules/@thi.ng/shader-ast/ast/sym.js","../../../../../node_modules/@thi.ng/shader-ast/ast/lit.js","../../../../../node_modules/@thi.ng/shader-ast/ast/item.js"],"sourcesContent":["import { isPlainObject } from \"@thi.ng/checks\";\nconst RE_VEC = /^[iub]?vec[234]$/;\nconst RE_MAT = /^mat[234]$/;\n/**\n * Returns true if given `t` is a {@link Term}-like object.\n *\n * @param t\n */\nexport const isTerm = (t) => isPlainObject(t) && !!t.tag && !!t.type;\n/**\n * Returns true, if given term evaluates to a boolean value.\n */\nexport const isBool = (t) => t.type === \"bool\";\n/**\n * Returns true, if given term evaluates to a float value.\n */\nexport const isFloat = (t) => t.type === \"float\";\n/**\n * Returns true, if given term evaluates to a signed integer value.\n */\nexport const isInt = (t) => t.type === \"int\";\n/**\n * Returns true, if given term evaluates to an unsigned integer value.\n */\nexport const isUint = (t) => t.type === \"uint\";\n/**\n * Returns true, if given term is a literal.\n */\nexport const isLit = (t) => t.tag === \"lit\";\n/**\n * Returns true, if given term is a float literal.\n */\nexport const isLitFloat = (t) => isLit(t) && isFloat(t);\n/**\n * Returns true, if given term is a signed integer literal.\n */\nexport const isLitInt = (t) => isLit(t) && isInt(t);\n/**\n * Returns true, if given term is a numeric literal (float, int, uint).\n */\nexport const isLitNumeric = (t) => isLit(t) && (isFloat(t) || isInt(t) || isUint(t));\n/**\n * Returns true, if given term evaluates to a vector value (vec, ivec, bvec).\n */\nexport const isVec = (t) => RE_VEC.test(t.type);\n/**\n * Returns true, if given term evaluates to a matrix value.\n */\nexport const isMat = (t) => RE_MAT.test(t.type);\n","let symID = 0;\n/**\n * Helper for deterministic code generation / testing. Resets sym ID\n * counter.\n */\nexport const resetSymID = () => (symID = 0);\n/**\n * Generates a new symbol name, e.g. `_sa2`. Uses base36 for counter to\n * keep names short.\n */\nexport const gensym = () => `_s${(symID++).toString(36)}`;\n","import { assert } from \"@thi.ng/api\";\nimport { isString } from \"@thi.ng/checks\";\nimport { illegalArgs } from \"@thi.ng/errors\";\nimport { gensym } from \"./idgen\";\nexport function sym(type, ...xs) {\n    let id;\n    let opts;\n    let init;\n    switch (xs.length) {\n        case 0:\n            if (!isString(type)) {\n                init = type;\n                type = init.type;\n            }\n            break;\n        case 1:\n            if (isString(xs[0])) {\n                id = xs[0];\n            }\n            else if (xs[0].tag) {\n                init = xs[0];\n            }\n            else {\n                opts = xs[0];\n            }\n            break;\n        case 2:\n            if (isString(xs[0])) {\n                [id, opts] = xs;\n            }\n            else {\n                [opts, init] = xs;\n            }\n            break;\n        case 3:\n            [id, opts, init] = xs;\n            break;\n        default:\n            illegalArgs();\n    }\n    return {\n        tag: \"sym\",\n        type,\n        id: id || gensym(),\n        opts: opts || {},\n        init: init,\n    };\n}\nexport const constSym = (type, id, opts, init) => sym(type, id || gensym(), Object.assign({ const: true }, opts), init);\n/**\n * Defines a new symbol with optional initial array values.\n *\n * Important: Array initializers are UNSUPPORTED in GLSL ES v1 (WebGL),\n * any code using such initializers will only work under WebGL2 or other\n * targets.\n */\nexport const arraySym = (type, id, opts = {}, init) => {\n    if (init && opts.num == null) {\n        opts.num = init.length;\n    }\n    assert(opts.num != null, \"missing array length\");\n    init &&\n        assert(opts.num === init.length, `expected ${opts.num} items in array, but got ${init.length}`);\n    const atype = (type + \"[]\");\n    return {\n        tag: \"sym\",\n        type: atype,\n        id: id || gensym(),\n        opts,\n        init: init\n            ? {\n                tag: \"array_init\",\n                type: atype,\n                init,\n            }\n            : undefined,\n    };\n};\nexport const input = (type, id, opts) => sym(type, id, Object.assign({ q: \"in\", type: \"in\" }, opts));\nexport const output = (type, id, opts) => sym(type, id, Object.assign({ q: \"out\", type: \"out\" }, opts));\nexport const uniform = (type, id, opts) => sym(type, id, Object.assign({ q: \"in\", type: \"uni\" }, opts));\n","import { isBoolean, isNumber } from \"@thi.ng/checks\";\nimport { isVec } from \"./checks\";\nexport const lit = (type, val, info) => ({\n    tag: \"lit\",\n    type,\n    info,\n    val,\n});\nexport const bool = (x) => lit(\"bool\", isNumber(x) ? !!x : x);\nexport const float = (x) => lit(\"float\", isBoolean(x) ? x & 1 : x);\nexport const int = (x) => lit(\"int\", isBoolean(x) ? x & 1 : isNumber(x) ? x | 0 : x);\nexport const uint = (x) => lit(\"uint\", isBoolean(x) ? x & 1 : isNumber(x) ? x >>> 0 : x);\nconst wrap = (type, ctor) => (x) => isNumber(x)\n    ? ctor(x)\n    : x !== undefined && !isVec(x) && x.type !== type\n        ? ctor(x)\n        : x;\n/**\n * Takes a plain number or numeric term and wraps it as float literal if\n * needed.\n *\n * @param x -\n */\nexport const wrapFloat = wrap(\"float\", float);\n/**\n * Takes a plain number or numeric term and wraps it as signed integer\n * literal if needed.\n *\n * @param x -\n */\nexport const wrapInt = wrap(\"int\", int);\n/**\n * Takes a plain number or numeric term and wraps it as unsigned integer\n * literal if needed.\n *\n * @param x -\n */\nexport const wrapUint = wrap(\"uint\", uint);\n/**\n * Takes a plain number or numeric term and wraps it as boolean literal\n * if needed.\n *\n * @param x -\n */\nexport const wrapBool = wrap(\"bool\", bool);\nexport const TRUE = bool(true);\nexport const FALSE = bool(false);\nexport const FLOAT0 = float(0);\nexport const FLOAT1 = float(1);\nexport const FLOAT2 = float(2);\nexport const FLOAT05 = float(0.5);\nexport const INT0 = int(0);\nexport const INT1 = int(1);\nexport const UINT0 = uint(0);\nexport const UINT1 = uint(1);\nexport const PI = float(Math.PI);\nexport const TAU = float(Math.PI * 2);\nexport const HALF_PI = float(Math.PI / 2);\nexport const SQRT2 = float(Math.SQRT2);\nconst $gvec = (wrap, init) => (xs) => [xs[0] === undefined ? init : wrap(xs[0]), ...xs.slice(1).map(wrap)];\nconst $vec = $gvec(wrapFloat, FLOAT0);\nconst $ivec = $gvec(wrapInt, INT0);\nconst $uvec = $gvec(wrapUint, UINT0);\nconst $bvec = $gvec(wrapBool, FALSE);\nconst $info = (xs, info) => isVec(xs[0]) ? xs[0].type[0] : info[xs.length];\nconst $gvec2 = (type, ctor, xs) => lit(type, (xs = ctor(xs)), $info(xs, [\"n\", \"n\"]));\nconst $gvec3 = (type, ctor, xs) => lit(type, (xs = ctor(xs)), xs.length === 2 ? \"vn\" : $info(xs, [\"n\", \"n\"]));\nconst $gvec4 = (type, ctor, xs) => lit(type, (xs = ctor(xs)), xs.length === 2\n    ? isVec(xs[1])\n        ? \"vv\"\n        : \"vn\"\n    : $info(xs, [\"n\", \"n\", , \"vnn\"]));\nconst $gmat = (type, info, xs) => lit(type, (xs = $vec(xs)), info[xs.length]);\n// prettier-ignore\nexport function vec2(...xs) {\n    return $gvec2(\"vec2\", $vec, xs);\n}\nexport function vec3(...xs) {\n    return $gvec3(\"vec3\", $vec, xs);\n}\nexport function vec4(...xs) {\n    return $gvec4(\"vec4\", $vec, xs);\n}\n// prettier-ignore\nexport function ivec2(...xs) {\n    return $gvec2(\"ivec2\", $ivec, xs);\n}\nexport function ivec3(...xs) {\n    return $gvec3(\"ivec3\", $ivec, xs);\n}\nexport function ivec4(...xs) {\n    return $gvec4(\"ivec4\", $ivec, xs);\n}\n// prettier-ignore\nexport function uvec2(...xs) {\n    return $gvec2(\"uvec2\", $uvec, xs);\n}\nexport function uvec3(...xs) {\n    return $gvec3(\"uvec3\", $uvec, xs);\n}\nexport function uvec4(...xs) {\n    return $gvec4(\"uvec4\", $uvec, xs);\n}\n// prettier-ignore\nexport function bvec2(...xs) {\n    return $gvec2(\"bvec2\", $bvec, xs);\n}\nexport function bvec3(...xs) {\n    return $gvec3(\"bvec3\", $bvec, xs);\n}\nexport function bvec4(...xs) {\n    return $gvec4(\"bvec4\", $bvec, xs);\n}\nexport function mat2(...xs) {\n    return $gmat(\"mat2\", [\"n\", \"n\", \"vv\"], xs);\n}\nexport function mat3(...xs) {\n    return $gmat(\"mat3\", [\"n\", \"n\", , \"vvv\"], xs);\n}\nexport function mat4(...xs) {\n    return $gmat(\"mat4\", [\"n\", \"n\", , , \"vvvv\"], xs);\n}\n","import { bool, float, int, uint, vec2, vec3, vec4 } from \"./lit\";\n/**\n * Returns base type for given term. Used for array ops.\n *\n * @example\n * ```ts\n * itemType(\"vec2[]\") => \"vec2\"\n * ```\n */\nexport const itemType = (type) => type.replace(\"[]\", \"\");\n/**\n * Takes a numeric term and a plain number, returns number wrapped in\n * typed literal compatible with term.\n *\n * @param t -\n * @param x -\n */\nexport const numberWithMatchingType = (t, x) => {\n    const id = t.type[0];\n    return id === \"i\"\n        ? int(x)\n        : id === \"u\"\n            ? uint(x)\n            : id === \"b\"\n                ? bool(x)\n                : float(x);\n};\nexport const matchingPrimFor = (t, x) => {\n    const ctor = { vec2, vec3, vec4 }[t.type];\n    return ctor ? ctor(x) : x;\n};\nexport const matchingBoolType = (t) => ({\n    float: \"bool\",\n    int: \"bool\",\n    uint: \"bool\",\n    vec2: \"bvec2\",\n    ivec2: \"bvec2\",\n    uvec2: \"bvec2\",\n    vec3: \"bvec3\",\n    ivec3: \"bvec3\",\n    uvec3: \"bvec3\",\n    vec4: \"bvec4\",\n    ivec4: \"bvec4\",\n    uvec4: \"bvec4\",\n}[t.type]);\n"],"names":[],"mappings":";;;;AACA,MAAM,MAAM,GAAG,kBAAkB,CAAC;AAClC,MAAM,MAAM,GAAG,YAAY,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACY,MAAC,MAAM,GAAG,CAAC,CAAC,KAAK,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK;AAiCrE;AACA;AACA;AACY,MAAC,KAAK,GAAG,CAAC,CAAC,KAAK,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE;AAChD;AACA;AACA;AACY,MAAC,KAAK,GAAG,CAAC,CAAC,KAAK,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI;;AChD9C,IAAI,KAAK,GAAG,CAAC,CAAC;AAMd;AACA;AACA;AACA;AACY,MAAC,MAAM,GAAG,MAAM,CAAC,EAAE,EAAE,CAAC,KAAK,EAAE,EAAE,QAAQ,CAAC,EAAE,CAAC,CAAC;;ACNjD,SAAS,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE;AACjC,IAAI,IAAI,EAAE,CAAC;AACX,IAAI,IAAI,IAAI,CAAC;AACb,IAAI,IAAI,IAAI,CAAC;AACb,IAAI,QAAQ,EAAE,CAAC,MAAM;AACrB,QAAQ,KAAK,CAAC;AACd,YAAY,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AACjC,gBAAgB,IAAI,GAAG,IAAI,CAAC;AAC5B,gBAAgB,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AACjC,aAAa;AACb,YAAY,MAAM;AAClB,QAAQ,KAAK,CAAC;AACd,YAAY,IAAI,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE;AACjC,gBAAgB,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AAC3B,aAAa;AACb,iBAAiB,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;AAChC,gBAAgB,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AAC7B,aAAa;AACb,iBAAiB;AACjB,gBAAgB,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AAC7B,aAAa;AACb,YAAY,MAAM;AAClB,QAAQ,KAAK,CAAC;AACd,YAAY,IAAI,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE;AACjC,gBAAgB,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,EAAE,CAAC;AAChC,aAAa;AACb,iBAAiB;AACjB,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE,CAAC;AAClC,aAAa;AACb,YAAY,MAAM;AAClB,QAAQ,KAAK,CAAC;AACd,YAAY,CAAC,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE,CAAC;AAClC,YAAY,MAAM;AAClB,QAAQ;AACR,YAAY,WAAW,EAAE,CAAC;AAC1B,KAAK;AACL,IAAI,OAAO;AACX,QAAQ,GAAG,EAAE,KAAK;AAClB,QAAQ,IAAI;AACZ,QAAQ,EAAE,EAAE,EAAE,IAAI,MAAM,EAAE;AAC1B,QAAQ,IAAI,EAAE,IAAI,IAAI,EAAE;AACxB,QAAQ,IAAI,EAAE,IAAI;AAClB,KAAK,CAAC;AACN,CAAC;AA+BW,MAAC,KAAK,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,IAAI,KAAK,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,IAAI,CAAC,EAAE;AACzF,MAAC,MAAM,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,IAAI,KAAK,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,IAAI,CAAC,EAAE;AAC5F,MAAC,OAAO,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,IAAI,KAAK,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,IAAI,CAAC;;AC9E/F,MAAM,GAAG,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,MAAM;AACzC,IAAI,GAAG,EAAE,KAAK;AACd,IAAI,IAAI;AACR,IAAI,IAAI;AACR,IAAI,GAAG;AACP,CAAC,CAAC,CAAC;AACI,MAAM,IAAI,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AAClD,MAAC,KAAK,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;AAC5D,MAAM,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAC9E,MAAM,IAAI,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AACzF,MAAM,IAAI,GAAG,CAAC,IAAI,EAAE,IAAI,KAAK,CAAC,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC;AAC/C,MAAM,IAAI,CAAC,CAAC,CAAC;AACb,MAAM,CAAC,KAAK,SAAS,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI;AACrD,UAAU,IAAI,CAAC,CAAC,CAAC;AACjB,UAAU,CAAC,CAAC;AACZ;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AAwBlC,MAAC,MAAM,GAAG,KAAK,CAAC,CAAC,EAAE;AACnB,MAAC,MAAM,GAAG,KAAK,CAAC,CAAC,EAAE;AACnB,MAAC,MAAM,GAAG,KAAK,CAAC,CAAC,EAAE;AACnB,MAAC,OAAO,GAAG,KAAK,CAAC,GAAG,EAAE;AASlC,MAAM,KAAK,GAAG,CAAC,IAAI,EAAE,IAAI,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;AAC3G,MAAM,IAAI,GAAG,KAAK,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;AAItC,MAAM,KAAK,GAAG,CAAC,EAAE,EAAE,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC;AAC3E,MAAM,MAAM,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,KAAK,GAAG,CAAC,IAAI,GAAG,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AACrF,MAAM,MAAM,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,KAAK,GAAG,CAAC,IAAI,GAAG,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,KAAK,CAAC,GAAG,IAAI,GAAG,KAAK,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AAC9G,MAAM,MAAM,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,KAAK,GAAG,CAAC,IAAI,GAAG,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,KAAK,CAAC;AAC7E,MAAM,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAClB,UAAU,IAAI;AACd,UAAU,IAAI;AACd,MAAM,KAAK,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;AAEtC;AACO,SAAS,IAAI,CAAC,GAAG,EAAE,EAAE;AAC5B,IAAI,OAAO,MAAM,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;AACpC,CAAC;AACM,SAAS,IAAI,CAAC,GAAG,EAAE,EAAE;AAC5B,IAAI,OAAO,MAAM,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;AACpC,CAAC;AACM,SAAS,IAAI,CAAC,GAAG,EAAE,EAAE;AAC5B,IAAI,OAAO,MAAM,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;AACpC;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,QAAQ,GAAG,CAAC,IAAI,KAAK,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,EAAE;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,sBAAsB,GAAG,CAAC,CAAC,EAAE,CAAC,KAAK;AAChD,IAAI,MAAM,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACzB,IAAI,OAAO,EAAE,KAAK,GAAG;AACrB,UAAU,GAAG,CAAC,CAAC,CAAC;AAChB,UAAU,EAAE,KAAK,GAAG;AACpB,cAAc,IAAI,CAAC,CAAC,CAAC;AACrB,cAAc,EAAE,KAAK,GAAG;AACxB,kBAAkB,IAAI,CAAC,CAAC,CAAC;AACzB,kBAAkB,KAAK,CAAC,CAAC,CAAC,CAAC;AAC3B;;;;"}