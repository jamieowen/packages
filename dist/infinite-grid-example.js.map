{
  "version": 3,
  "sources": ["/Users/jamieowen/Workspace/packages/examples/src/infinite-grid-example.ts"],
  "sourcesContent": ["import {\n  GridCell,\n  GridOpts,\n  infiniteGrid,\n  infiniteSubGrid,\n  SubGridCell,\n  SubGridOpts,\n} from \"@jamieowen/layout\";\nimport {\n  sketch,\n  createGeometryFactory,\n  GeometryAlignment,\n  gestureStream3d,\n  dragGesture3d,\n  createDomeSimpleLight,\n  createDomeSimpleOpts,\n} from \"@jamieowen/three\";\nimport {\n  MeshStandardMaterial,\n  InstancedMesh,\n  Color,\n  Object3D,\n  DynamicDrawUsage,\n  Group,\n  BoxBufferGeometry,\n  Matrix4,\n} from \"three\";\nimport { createGui } from \"@jamieowen/gui\";\nimport { sync, reactive, trace } from \"@thi.ng/rstream\";\nimport { Smush32 } from \"@thi.ng/random\";\nimport { mulN2, sub3 } from \"@thi.ng/vectors\";\n\nconst boxGeometry = new BoxBufferGeometry(1, 1, 1);\nboxGeometry.applyMatrix4(new Matrix4().makeTranslation(0.5, 0.5, 0.5));\n\nconst createInstancedMesh = (parent: Object3D, count: number) => {\n  const instanced = new InstancedMesh(\n    boxGeometry,\n    // geometry.create(\"box\", GeometryAlignment.CENTER),\n    new MeshStandardMaterial({\n      color: \"white\",\n    }),\n    count\n  );\n  parent.add(instanced as Object3D);\n  // instanced.instanceColor.\n  instanced.instanceMatrix.setUsage(DynamicDrawUsage);\n\n  return instanced;\n};\n\nconst gui = createGui({\n  grid: true,\n  subgrid: true,\n  width: [20, 10, 50, 1],\n  height: [20, 10, 50, 1],\n  viewportX: [15, 5, 20, 1],\n  viewportY: [10, 5, 20, 1],\n  subdivCond: [0.6, 0.2, 1, 0.01],\n  seed: [1, 1, 2, 0.001],\n});\n\n/**\n *\n * Create Infinite Grid Sketch.\n *\n */\nsketch(\n  ({\n    configure,\n    scene,\n    render,\n    controls,\n    renderer,\n    camera,\n    resize,\n    domElement,\n  }) => {\n    renderer.shadowMap.enabled = true;\n    camera.fov = 50;\n    camera.updateProjectionMatrix();\n\n    controls.object.position.set(0, 4.5, 5);\n    controls.object.position.multiplyScalar(3);\n    controls.target.set(0, -1, 0);\n    controls.update();\n\n    // PRNG\n    const rand = new Smush32(0xff404);\n    let seedOffset = 1;\n    const seedRandom = (id: number) => rand.seed(id * seedOffset).float();\n    // Scene\n    const group = new Group();\n    scene.add(group);\n    // const sphereBox = createSphere(scene);\n    // const lights = createLights(scene);\n    // const bounds = createBoundsMesh(scene);\n\n    const dome = createDomeSimpleLight(\n      scene,\n      createDomeSimpleOpts({\n        color: \"whitesmoke\",\n        intensity: [0.3, 0.2, 0.3],\n        emissive: {\n          intensity: [0.2, 0.2],\n          offset: [\n            [0, 0, 0],\n            [0, 0, 0],\n          ],\n        },\n        showHelpers: false,\n      })\n    );\n\n    // Global Grid Position\n    const position = reactive([-183.5, 0.5] as [number, number]);\n    const viewport = [10, 6] as [number, number];\n    const dimensions = [2, 2] as [number, number];\n\n    // bounds.scale.set(viewport[0], 2, viewport[1]);\n    // group.position.set(-viewport[0] / 2, 0, -viewport[1] / 2);\n\n    // Create Instanced Mesh\n    const instanced = createInstancedMesh(group, 10000);\n    // instanced.castShadow = true;\n    // instanced.receiveShadow = true;\n\n    // Grid 1.\n    const opts1 = reactive<GridOpts>({\n      dimensions,\n      viewport,\n    });\n    const grid1 = infiniteGrid<number>(position, opts1);\n\n    // Subgrid 1\n    const opts2 = reactive<SubGridOpts>({\n      dimensions,\n      viewport,\n      maxDepth: 3,\n      subdivide: (cell) => seedRandom(cell[0]) > 0.8,\n    });\n    const grid2 = infiniteSubGrid(position, opts2);\n\n    // GUI Subscribe & Update Opts.\n    // + Bounds & Center Offset\n    const updateViewport = (\n      viewport: [number, number],\n      dimensions: [number, number],\n      subdiv: number = 0.6,\n      seed: number = 1\n    ) => {\n      opts1.next({\n        dimensions,\n        viewport,\n      });\n\n      opts2.next({\n        ...opts2.deref(),\n        dimensions,\n        viewport,\n        subdivide: (cell) => seedRandom(cell[0]) > subdiv,\n      });\n\n      seedOffset = seed;\n      group.position.set(-viewport[0] / 2, 0, -viewport[1] / 2);\n    };\n    updateViewport(viewport, dimensions);\n\n    gui.subscribe({\n      next: ({ values }) => {\n        let vp = [values.viewportX, values.viewportY] as [number, number];\n        let dims = [values.width * 0.1, values.height * 0.1] as [\n          number,\n          number\n        ];\n\n        updateViewport(vp, dims, values.subdivCond, values.seed);\n      },\n    });\n\n    // Create Render Method & Helpers\n    const obj3d = new Object3D();\n    const color = new Color();\n    const t1 = [];\n    // const t2 = [];\n    // const t3 = [];\n    // const t4 = [];\n\n    sync({\n      src: {\n        grid1,\n        grid2,\n      },\n    }).subscribe({\n      next: ({ grid1, grid2 }: { grid1: GridCell[]; grid2: SubGridCell[] }) => {\n        // console.log(\"GRID UPDATE\", items.length);\n        let idx = 0;\n\n        const guiopts = gui.deref();\n        const dims = opts1.deref().dimensions;\n        const yscale = 0;\n\n        const s1 = 1; //0.9;\n        // const s2 = 1; //0.7;\n        // scale\n        const d1 = mulN2(t1, dims, s1);\n        // const d2 = mulN2(t2, dims, s2);\n        // offset\n        // const d3 = mulN2(null, sub3(t3, dims, d1), 0.5);\n        // const d4 = mulN2(null, sub3(t4, dims, d2), 0.5);\n\n        // Grid 1\n        if (guiopts.values.grid) {\n          for (let cell of grid1) {\n            let r = seedRandom(cell.id);\n            obj3d.position.x = cell.local[0]; // + d3[0];\n            obj3d.position.y = r * yscale;\n            obj3d.position.z = cell.local[1]; // + d3[1];\n\n            obj3d.scale.set(d1[0], 0.1, d1[1]);\n            obj3d.updateMatrixWorld();\n            instanced.setMatrixAt(idx, obj3d.matrixWorld);\n\n            color.setHSL(0, 0, cell.cell[0] % 2 === 0 ? 0.5 : 1);\n            instanced.setColorAt(idx, color);\n            idx++;\n          }\n        }\n\n        // Subgrid 1\n        if (guiopts.values.subgrid) {\n          for (let cell of grid2) {\n            let r = seedRandom(cell.id);\n            obj3d.position.x = cell.local[0]; // + d4[0];\n            obj3d.position.y = r * yscale + 0.15;\n            obj3d.position.z = cell.local[1]; // + d4[1];\n\n            let step = cell.step; // fract part of subdivision.\n            // obj3d.scale.set(0.1, 0.1, 0.1);\n            obj3d.scale.set(d1[0] * step, 2.2 * r, d1[1] * step);\n            // obj3d.scale.set(d2[0] * step, 2.5 * r, d2[1] * step);\n            // obj3d.scale.set(d2[0] * step, 1, d2[1] * step);\n            obj3d.updateMatrixWorld();\n            instanced.setMatrixAt(idx, obj3d.matrixWorld);\n\n            const xodd = cell.cell[0] % 2;\n            color.setHSL(\n              (cell.world[0] * 0.005) % 1,\n              0.85,\n              0.65 + r * 0.35 - xodd * 0.3\n            );\n            instanced.setColorAt(idx, color);\n            idx++;\n          }\n        }\n        instanced.count = idx;\n        instanced.instanceMatrix.needsUpdate = true;\n        instanced.instanceColor.needsUpdate = true;\n      },\n      error: (err) => {\n        throw err;\n      },\n    });\n\n    const gesture$ = gestureStream3d(domElement, camera, resize);\n\n    dragGesture3d(gesture$, {\n      friction: 0.05,\n      maxSpeed: 10,\n      initialPosition: [position.deref()[0], 0, position.deref()[1]],\n    }).subscribe({\n      next: ({ particle }) => {\n        position.next([particle.data.position[0], particle.data.position[2]]);\n      },\n    });\n\n    render(() => {});\n  }\n);\n"],
  "mappings": "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",
  "names": []
}
