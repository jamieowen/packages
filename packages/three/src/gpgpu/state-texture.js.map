{
  "version": 3,
  "sources": ["/Users/jamieowen/Workspace/packages/packages/three/src/gpgpu/state-texture.ts"],
  "sourcesContent": ["import {\n  RawShaderMaterial,\n  BufferGeometry,\n  Scene,\n  Mesh,\n  DataTexture,\n  WebGLRenderTarget,\n  WebGLRenderer,\n  OrthographicCamera,\n  RGBAFormat,\n  FloatType,\n  ClampToEdgeWrapping,\n  NearestFilter,\n  BufferAttribute,\n  DoubleSide,\n} from \"three\";\nimport { GPGPUSetup, gpgpuSetup } from \"@jamieowen/webgl\";\n\nconst defaultRttOpts = {\n  format: RGBAFormat,\n  type: FloatType,\n  // mapping: UVMapping,\n  wrapS: ClampToEdgeWrapping,\n  wrapT: ClampToEdgeWrapping,\n  minFilter: NearestFilter,\n  magFilter: NearestFilter,\n  stencilBuffer: false,\n  depthBuffer: false,\n};\n\nconst createTexture = (width: number, height: number) => {\n  return new WebGLRenderTarget(width, height, {\n    format: RGBAFormat,\n    type: FloatType,\n    // mapping: UVMapping,\n    wrapS: ClampToEdgeWrapping,\n    wrapT: ClampToEdgeWrapping,\n    minFilter: NearestFilter,\n    magFilter: NearestFilter,\n    stencilBuffer: false,\n    depthBuffer: false,\n  });\n};\n\nconst createGeometry = (buffer: Float32Array) => {\n  const geometry = new BufferGeometry();\n  geometry.setAttribute(\"position\", new BufferAttribute(buffer, 3));\n  return geometry;\n};\n\nexport class GPGPUState {\n  setup: ReturnType<typeof gpgpuSetup>;\n  renderer: WebGLRenderer;\n  states: WebGLRenderTarget[];\n  material: RawShaderMaterial;\n  writeMaterial: RawShaderMaterial;\n  geometry: BufferGeometry;\n  camera: OrthographicCamera;\n  scene: Scene = new Scene();\n  mesh: Mesh;\n\n  /**\n   *\n   * @param renderer\n   * @param setup\n   */\n  constructor(renderer: WebGLRenderer, setup: ReturnType<typeof gpgpuSetup>) {\n    this.setup = setup;\n    this.renderer = renderer;\n    // Create state textures.\n    this.states = new Array(setup.count)\n      .fill(0)\n      .map(() => createTexture(setup.width, setup.height));\n    // Main ping/pong update material\n    this.material = new RawShaderMaterial({\n      vertexShader: setup.vertexSource,\n      fragmentShader: setup.fragmentSource,\n      depthTest: false,\n      depthWrite: false,\n      // side: setup.geomType === \"triangle\" ? BackSide : FrontSide,\n      side: DoubleSide,\n      uniforms: {\n        // TODO: need to make dynamic\n        state_1: { value: null },\n        state_2: { value: null },\n      },\n    });\n    // Material to write a data texture to the output buffer.\n    this.writeMaterial = new RawShaderMaterial({\n      vertexShader: setup.vertexSource,\n      fragmentShader: setup.fragmentWriteSource,\n      depthTest: false,\n      depthWrite: false,\n      side: DoubleSide,\n      uniforms: {\n        inputSource: { value: null },\n      },\n    });\n    this.geometry = createGeometry(setup.positionBuffer);\n    this.mesh = new Mesh(this.geometry, this.material);\n    this.camera = new OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0, 1);\n    this.scene.add(this.mesh);\n  }\n\n  /**\n   * Set the supplied data as all states and\n   * write it to the current output buffer.\n   *\n   * This is replaces the current state and\n   * @param data\n   */\n  write(data: DataTexture) {\n    this.writeMaterial.uniforms[\"inputSource\"].value = data;\n    this.mesh.material = this.writeMaterial;\n    // TODO : unnecessary to write all states.\n    this.states.forEach((state) => {\n      this.renderer.setRenderTarget(state);\n      this.renderer.render(this.scene, this.camera);\n    });\n    this.renderer.setRenderTarget(null);\n    this.mesh.material = this.material;\n  }\n\n  /**\n   * Update the state using the supplied update shader.\n   * Number of state textures should be equal to count + 1,\n   * as the the texture in state[0] will be the output\n   * texture.\n   */\n  update() {\n    // Update state uniforms\n    // this.states.forEach((state, i) => {\n    //   this.material.uniforms[`state_${i}`].value = state.texture;\n    // });\n    // Render\n    this.material.uniforms[\"state_1\"].value = this.states[1].texture;\n    if (this.states.length >= 3) {\n      this.material.uniforms[\"state_2\"].value = this.states[2].texture;\n    }\n    this.renderer.setRenderTarget(this.states[0]);\n    this.renderer.render(this.scene, this.camera);\n    this.renderer.setRenderTarget(null);\n    this.nextState();\n  }\n\n  get output() {\n    return this.states[0];\n  }\n\n  /**\n   * Return a preview texture ( that is not being rendered to next )\n   */\n  get preview() {\n    return this.states[1];\n  }\n\n  /**\n   * Advance the states along from left to right.\n   * The texture in the state[0] position will\n   * be the next output buffer.\n   *\n   * State at > state[1] can be used as a texture for preview.\n   */\n  nextState() {\n    let prevState = this.states[this.states.length - 1];\n    for (let i = 0; i < this.states.length; i++) {\n      let current = this.states[i];\n      this.states[i] = prevState;\n      prevState = current;\n    }\n  }\n}\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA,MAAM,iBAAiB;AAAA,EACrB,QAAQ;AAAA,EACR,MAAM;AAAA,EAEN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,WAAW;AAAA,EACX,WAAW;AAAA,EACX,eAAe;AAAA,EACf,aAAa;AAAA;AAGf,MAAM,gBAAgB,CAAC,OAAe,WAAmB;AACvD,SAAO,IAAI,kBAAkB,OAAO,QAAQ;AAAA,IAC1C,QAAQ;AAAA,IACR,MAAM;AAAA,IAEN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,WAAW;AAAA,IACX,WAAW;AAAA,IACX,eAAe;AAAA,IACf,aAAa;AAAA;AAAA;AAIjB,MAAM,iBAAiB,CAAC,WAAyB;AAC/C,QAAM,WAAW,IAAI;AACrB,WAAS,aAAa,YAAY,IAAI,gBAAgB,QAAQ;AAC9D,SAAO;AAAA;AAGF,wBAAiB;AAAA,EAgBtB,YAAY,UAAyB,OAAsC;AAR3E,iBAAe,IAAI;AASjB,SAAK,QAAQ;AACb,SAAK,WAAW;AAEhB,SAAK,SAAS,IAAI,MAAM,MAAM,OAC3B,KAAK,GACL,IAAI,MAAM,cAAc,MAAM,OAAO,MAAM;AAE9C,SAAK,WAAW,IAAI,kBAAkB;AAAA,MACpC,cAAc,MAAM;AAAA,MACpB,gBAAgB,MAAM;AAAA,MACtB,WAAW;AAAA,MACX,YAAY;AAAA,MAEZ,MAAM;AAAA,MACN,UAAU;AAAA,QAER,SAAS,CAAE,OAAO;AAAA,QAClB,SAAS,CAAE,OAAO;AAAA;AAAA;AAItB,SAAK,gBAAgB,IAAI,kBAAkB;AAAA,MACzC,cAAc,MAAM;AAAA,MACpB,gBAAgB,MAAM;AAAA,MACtB,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,MAAM;AAAA,MACN,UAAU;AAAA,QACR,aAAa,CAAE,OAAO;AAAA;AAAA;AAG1B,SAAK,WAAW,eAAe,MAAM;AACrC,SAAK,OAAO,IAAI,KAAK,KAAK,UAAU,KAAK;AACzC,SAAK,SAAS,IAAI,mBAAmB,MAAM,KAAK,KAAK,MAAM,GAAG;AAC9D,SAAK,MAAM,IAAI,KAAK;AAAA;AAAA,EAUtB,MAAM,MAAmB;AACvB,SAAK,cAAc,SAAS,eAAe,QAAQ;AACnD,SAAK,KAAK,WAAW,KAAK;AAE1B,SAAK,OAAO,QAAQ,CAAC,UAAU;AAC7B,WAAK,SAAS,gBAAgB;AAC9B,WAAK,SAAS,OAAO,KAAK,OAAO,KAAK;AAAA;AAExC,SAAK,SAAS,gBAAgB;AAC9B,SAAK,KAAK,WAAW,KAAK;AAAA;AAAA,EAS5B,SAAS;AAMP,SAAK,SAAS,SAAS,WAAW,QAAQ,KAAK,OAAO,GAAG;AACzD,QAAI,KAAK,OAAO,UAAU,GAAG;AAC3B,WAAK,SAAS,SAAS,WAAW,QAAQ,KAAK,OAAO,GAAG;AAAA;AAE3D,SAAK,SAAS,gBAAgB,KAAK,OAAO;AAC1C,SAAK,SAAS,OAAO,KAAK,OAAO,KAAK;AACtC,SAAK,SAAS,gBAAgB;AAC9B,SAAK;AAAA;AAAA,MAGH,SAAS;AACX,WAAO,KAAK,OAAO;AAAA;AAAA,MAMjB,UAAU;AACZ,WAAO,KAAK,OAAO;AAAA;AAAA,EAUrB,YAAY;AACV,QAAI,YAAY,KAAK,OAAO,KAAK,OAAO,SAAS;AACjD,aAAS,IAAI,GAAG,IAAI,KAAK,OAAO,QAAQ,KAAK;AAC3C,UAAI,UAAU,KAAK,OAAO;AAC1B,WAAK,OAAO,KAAK;AACjB,kBAAY;AAAA;AAAA;AAAA;",
  "names": []
}
