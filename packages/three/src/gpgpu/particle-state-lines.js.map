{
  "version": 3,
  "sources": ["/Users/jamieowen/Workspace/packages/packages/three/src/gpgpu/particle-state-lines.ts"],
  "sourcesContent": ["import {\n  BufferAttribute,\n  BufferGeometry,\n  LineSegments,\n  RawShaderMaterial,\n  Vector2,\n} from \"three\";\nimport { compileProgramAst, particleLinesProgram } from \"@jamieowen/webgl\";\nimport { GPGPUState } from \"../gpgpu\";\n\nconst particleStateLinesMaterial = () => {\n  const { fragmentSource, vertexSource } = compileProgramAst(\n    particleLinesProgram()\n  );\n  const material = new RawShaderMaterial({\n    // vertexColors: addColor,\n    vertexShader: vertexSource,\n    fragmentShader: fragmentSource,\n    linewidth: 2,\n  });\n  material.uniforms[\"state_1\"] = { value: null };\n  material.uniforms[\"state_2\"] = { value: null };\n  material.uniforms[\"resolution\"] = { value: new Vector2() };\n  return material;\n};\n\n/**\n *\n * Particle State.\n * Lines Geometry.\n */\nconst particleStateLinesGeometry = (count: number, color?: BufferAttribute) => {\n  const geometry = new BufferGeometry();\n  const position = new BufferAttribute(\n    new Float32Array(count * 3 * 2).fill(0),\n    3\n  );\n  // Offsets span from 0 to count * 2.\n  // From this, the line segment start and end is determined by offset % 2\n  // And the offset for reading from the texture is offset / 2\n  const offset = new BufferAttribute(\n    new Float32Array(\n      // new Array(count * 2).fill(0).map((_v, i) => Math.floor(i / 2))\n      new Array(count * 2).fill(0).map((_v, i) => i)\n    ),\n    1\n  );\n  geometry.setAttribute(\"position\", position);\n  geometry.setAttribute(\"offset\", offset);\n\n  if (color) {\n    geometry.setAttribute(\"color\", color);\n  }\n\n  return geometry;\n};\n\n/**\n *\n * Particle State.\n * Lines Rendering.\n *\n */\nexport class ParticleStateLineSegments extends LineSegments {\n  state: GPGPUState;\n  constructor(count: number, state: GPGPUState, color?: BufferAttribute) {\n    super(\n      particleStateLinesGeometry(count, color),\n      particleStateLinesMaterial()\n    );\n    this.state = state;\n    if (this.state.states.length < 3) {\n      throw new Error(\n        \"Lines segment renderer needs an additional state[2] to render.\"\n      );\n    }\n  }\n  onBeforeRender = () => {\n    const material = this.material as RawShaderMaterial;\n    material.uniforms.state_1.value = this.state.preview.texture;\n    material.uniforms.state_2.value = this.state.states[2].texture;\n    material.uniforms.resolution.value.x = this.state.setup.width;\n    material.uniforms.resolution.value.y = this.state.setup.height;\n  };\n}\n\nexport const createParticleStateLineSegments = (\n  count: number,\n  state: GPGPUState,\n  color?: BufferAttribute\n) => {\n  return new ParticleStateLineSegments(count, state, color);\n};\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAGA,MAAM,6BAA6B,MAAM;AACvC,QAAM,CAAE,gBAAgB,gBAAiB,kBACvC;AAEF,QAAM,WAAW,IAAI,kBAAkB;AAAA,IAErC,cAAc;AAAA,IACd,gBAAgB;AAAA,IAChB,WAAW;AAAA;AAEb,WAAS,SAAS,aAAa,CAAE,OAAO;AACxC,WAAS,SAAS,aAAa,CAAE,OAAO;AACxC,WAAS,SAAS,gBAAgB,CAAE,OAAO,IAAI;AAC/C,SAAO;AAAA;AAQT,MAAM,6BAA6B,CAAC,OAAe,UAA4B;AAC7E,QAAM,WAAW,IAAI;AACrB,QAAM,WAAW,IAAI,gBACnB,IAAI,aAAa,QAAQ,IAAI,GAAG,KAAK,IACrC;AAKF,QAAM,SAAS,IAAI,gBACjB,IAAI,aAEF,IAAI,MAAM,QAAQ,GAAG,KAAK,GAAG,IAAI,CAAC,IAAI,MAAM,KAE9C;AAEF,WAAS,aAAa,YAAY;AAClC,WAAS,aAAa,UAAU;AAEhC,MAAI,OAAO;AACT,aAAS,aAAa,SAAS;AAAA;AAGjC,SAAO;AAAA;AASF,+CAAwC,aAAa;AAAA,EAE1D,YAAY,OAAe,OAAmB,OAAyB;AACrE,UACE,2BAA2B,OAAO,QAClC;AASJ,0BAAiB,MAAM;AACrB,YAAM,WAAW,KAAK;AACtB,eAAS,SAAS,QAAQ,QAAQ,KAAK,MAAM,QAAQ;AACrD,eAAS,SAAS,QAAQ,QAAQ,KAAK,MAAM,OAAO,GAAG;AACvD,eAAS,SAAS,WAAW,MAAM,IAAI,KAAK,MAAM,MAAM;AACxD,eAAS,SAAS,WAAW,MAAM,IAAI,KAAK,MAAM,MAAM;AAAA;AAZxD,SAAK,QAAQ;AACb,QAAI,KAAK,MAAM,OAAO,SAAS,GAAG;AAChC,YAAM,IAAI,MACR;AAAA;AAAA;AAAA;AAaD,aAAM,kCAAkC,CAC7C,OACA,OACA,UACG;AACH,SAAO,IAAI,0BAA0B,OAAO,OAAO;AAAA;",
  "names": []
}
