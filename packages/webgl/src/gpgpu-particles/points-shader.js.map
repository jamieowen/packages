{
  "version": 3,
  "sources": ["/Users/jamieowen/Workspace/packages/packages/webgl/src/gpgpu-particles/points-shader.ts"],
  "sourcesContent": ["import {\n  program,\n  defMain,\n  uniform,\n  assign,\n  mul,\n  vec4,\n  input,\n  sym,\n  vec2,\n  div,\n  $x,\n  mod,\n  $y,\n  texture,\n  $xyz,\n  $w,\n  float,\n  output,\n} from \"@thi.ng/shader-ast\";\nimport { GLSLTarget } from \"@thi.ng/shader-ast-glsl\";\nimport { ProgramAst } from \"../shaders/ast-compile-helpers\";\n\nexport const pointsVertexShader = (target: GLSLTarget) => {\n  const projectionMatrix = uniform(\"mat4\", \"projectionMatrix\");\n  const modelViewMatrix = uniform(\"mat4\", \"modelViewMatrix\");\n  const resolution = uniform(\"vec2\", \"resolution\");\n  const state_1 = uniform(\"sampler2D\", \"state_1\");\n  const point_size = uniform(\"float\", \"point_size\");\n\n  // Attributes\n  const position = input(\"vec3\", \"position\");\n  const offset = input(\"float\", \"offset\");\n  const color = input(\"vec3\", \"color\");\n\n  // Varyings\n  const vColor = output(\"vec3\", \"vColor\");\n\n  // Read Values\n  const uv = sym(\n    div(\n      vec2(div(offset, $x(resolution)), mod(offset, $y(resolution))),\n      resolution\n    )\n  );\n  const readState = sym(texture(state_1, uv));\n  const pos = $xyz(readState);\n  const age = $w(readState);\n\n  return program([\n    // Uniforms\n    projectionMatrix,\n    modelViewMatrix,\n    state_1,\n    point_size,\n    resolution,\n    // Attributes\n    position,\n    offset,\n    color,\n    vColor,\n    // Main\n    defMain(() => [\n      uv,\n      readState,\n      assign(target.gl_PointSize, point_size),\n      assign(vColor, color),\n      assign(\n        target.gl_Position,\n        mul(projectionMatrix, mul(modelViewMatrix, vec4(pos, 1.0)))\n      ),\n    ]),\n  ]);\n};\n\nexport const pointsFragmentShader = (target: GLSLTarget) => {\n  const vColor = input(\"vec3\", \"vColor\", { prec: \"highp\" });\n  return program([\n    vColor,\n    defMain(() => [assign(target.gl_FragColor, vec4(vColor, 1.0))]),\n  ]);\n};\n\nexport const particlePointsProgram = (): ProgramAst => {\n  return {\n    vertexShader: pointsVertexShader,\n    fragmentShader: pointsFragmentShader,\n  };\n};\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuBO,aAAM,qBAAqB,CAAC,WAAuB;AACxD,QAAM,mBAAmB,QAAQ,QAAQ;AACzC,QAAM,kBAAkB,QAAQ,QAAQ;AACxC,QAAM,aAAa,QAAQ,QAAQ;AACnC,QAAM,UAAU,QAAQ,aAAa;AACrC,QAAM,aAAa,QAAQ,SAAS;AAGpC,QAAM,WAAW,MAAM,QAAQ;AAC/B,QAAM,SAAS,MAAM,SAAS;AAC9B,QAAM,QAAQ,MAAM,QAAQ;AAG5B,QAAM,SAAS,OAAO,QAAQ;AAG9B,QAAM,KAAK,IACT,IACE,KAAK,IAAI,QAAQ,GAAG,cAAc,IAAI,QAAQ,GAAG,eACjD;AAGJ,QAAM,YAAY,IAAI,QAAQ,SAAS;AACvC,QAAM,MAAM,KAAK;AACjB,QAAM,MAAM,GAAG;AAEf,SAAO,QAAQ;AAAA,IAEb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IAEA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IAEA,QAAQ,MAAM;AAAA,MACZ;AAAA,MACA;AAAA,MACA,OAAO,OAAO,cAAc;AAAA,MAC5B,OAAO,QAAQ;AAAA,MACf,OACE,OAAO,aACP,IAAI,kBAAkB,IAAI,iBAAiB,KAAK,KAAK;AAAA;AAAA;AAAA;AAMtD,aAAM,uBAAuB,CAAC,WAAuB;AAC1D,QAAM,SAAS,MAAM,QAAQ,UAAU,CAAE,MAAM;AAC/C,SAAO,QAAQ;AAAA,IACb;AAAA,IACA,QAAQ,MAAM,CAAC,OAAO,OAAO,cAAc,KAAK,QAAQ;AAAA;AAAA;AAIrD,aAAM,wBAAwB,MAAkB;AACrD,SAAO;AAAA,IACL,cAAc;AAAA,IACd,gBAAgB;AAAA;AAAA;",
  "names": []
}
