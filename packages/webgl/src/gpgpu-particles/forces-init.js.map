{
  "version": 3,
  "sources": ["/Users/jamieowen/Workspace/packages/packages/webgl/src/gpgpu-particles/forces-init.ts"],
  "sourcesContent": ["import {\n  assign,\n  sym,\n  Sym,\n  Vec3Sym,\n  FloatSym,\n  Vec3Term,\n  add,\n  FloatTerm,\n  vec3,\n  mul,\n} from \"@thi.ng/shader-ast\";\nimport { curlNoise3 } from \"@thi.ng/shader-ast-stdlib\";\n\n/**\n * Forces\n */\n\n/**\n *\n * Standard interface for a force.\n * Used by the accumulateForces\n *\n * Accepts some values and returns a force creation function.\n *\n */\n\ntype Force = (\n  position: Vec3Sym,\n  velocity: Vec3Sym,\n  mass: FloatSym,\n  age: FloatSym\n) => Vec3Term;\n\n// TODO: This is not corrent - perhaps get rid of?\n// Arguments are not being resolved correctly,\ntype ForceFactory<T extends Array<T> = any[]> = (...any: T) => Force;\n\n/**\n *\n * Accumulates provided forces.\n * This is an 'inline' approach without using glsl functions.\n *\n * @example\n * // glsl output\n * vec3 transformP = position;\n * vec3 transformV = velocity;\n * transformV = transformV + vec3(0.0,0.23,0.0);\n * transformV = transformV + curlNoise(position,0.3);\n * // etc ( per force )\n *\n * transformP = position + velocity;\n * // cap velocity speed.\n *\n *\n * @param position\n * @param velocity\n * @param mass\n * @param age\n * @param forces\n */\nexport const accumulateForces = (\n  position: Vec3Sym,\n  velocity: Vec3Sym,\n  mass: FloatSym,\n  age: FloatSym,\n  forces: Force[]\n) => {\n  const transformP = sym(position);\n  const transformV = sym(vec3(0.0));\n  // const transformV = sym(velocity); // TODO\n  return ([\n    transformP,\n    transformV,\n    ...forces.map((f) =>\n      assign(transformV, add(transformV, f(position, velocity, mass, age)))\n    ),\n    assign(transformP, add(position, transformV)),\n    // temp ts fix??\n  ] as unknown) as [transformedP: Sym<\"vec3\">, transformedV: Sym<\"vec3\">];\n};\n\n// From Previous\n// Including velocity? - needs capping and resetting at emission point\n// const transformed = sym(\n//   add(position, add(velocity, add(gravity, mul(curl, vec3(curlScale)))))\n// );\n\n// No Velocity\n// const transformed = sym(\n//   add(position, add(gravity, mul(curl, curlScale)))\n// );\n\nexport const gravity: ForceFactory = (constant: Vec3Sym) => {\n  return (position) => {\n    // don't return a sym term here. Probably to map cat\n    return constant;\n  };\n};\n\nexport const curlPosition: ForceFactory = (\n  scale: FloatTerm,\n  input: FloatTerm\n) => {\n  return (position) => {\n    return mul(scale, curlNoise3(position, input));\n  };\n};\n"],
  "mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAiDO,aAAM,mBAAmB,CAC9B,UACA,UACA,MACA,KACA,WACG;AACH,QAAM,aAAa,IAAI;AACvB,QAAM,aAAa,IAAI,KAAK;AAE5B,SAAQ;AAAA,IACN;AAAA,IACA;AAAA,IACA,GAAG,OAAO,IAAI,CAAC,MACb,OAAO,YAAY,IAAI,YAAY,EAAE,UAAU,UAAU,MAAM;AAAA,IAEjE,OAAO,YAAY,IAAI,UAAU;AAAA;AAAA;AAgB9B,aAAM,UAAwB,CAAC,aAAsB;AAC1D,SAAO,CAAC,aAAa;AAEnB,WAAO;AAAA;AAAA;AAIJ,aAAM,eAA6B,CACxC,OACA,UACG;AACH,SAAO,CAAC,aAAa;AACnB,WAAO,IAAI,OAAO,WAAW,UAAU;AAAA;AAAA;",
  "names": []
}
