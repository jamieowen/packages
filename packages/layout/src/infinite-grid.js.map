{
  "version": 3,
  "sources": ["/Users/jamieowen/Workspace/packages/packages/layout/src/infinite-grid.ts"],
  "sourcesContent": ["import { Stream, sync } from \"@thi.ng/rstream\";\nimport { comp, iterator, map, range2d } from \"@thi.ng/transducers\";\nimport { ChangeMap } from \"./change-map\";\nimport { szudzikPairSigned } from \"./pairing-functions\";\nimport { GridCell, GridOpts } from \"./grid-types\";\n\nexport { reactive } from \"@thi.ng/rstream\";\n/**\n *\n * Return an infinite grid iterator given a start position,\n * grid cell and viewport dimensions.\n *\n * @param position\n * @param opts\n */\nexport const infiniteGridIterator = (\n  position: [number, number],\n  opts: GridOpts\n) => {\n  const [gw, gh] = opts.dimensions;\n  const [vw, vh] = opts.viewport;\n\n  const px = -position[0];\n  const py = -position[1];\n\n  // start cell x/y\n  const fromX = Math.floor(px / gw);\n  const fromY = Math.floor(py / gh);\n\n  // cell row / cols\n  const xCount = Math.ceil(vw / gw) + 1;\n  const yCount = Math.ceil(vh / gh) + 1;\n\n  const toX = fromX + xCount;\n  const toY = fromY + yCount;\n\n  return iterator(\n    comp(\n      map(([x, y]) => {\n        const wx = x * gw;\n        const wy = y * gh;\n        const id = szudzikPairSigned(x, y);\n        return {\n          id,\n          cell: [x, y],\n          world: [wx, wy],\n          local: [wx - px, wy - py],\n        } as GridCell;\n      })\n    ),\n    range2d(fromX, toX, fromY, toY)\n  );\n};\n\n/**\n * Creates a reactive infinite grid with\n * @param position\n * @param opts\n */\nexport function infiniteGrid<T = any>(\n  position: Stream<[number, number]>,\n  opts: Stream<GridOpts>,\n  handle?: {\n    add: (cell: GridCell) => T;\n    remove: (id: number, handler: T) => void;\n    update: (cell: GridCell, handler: T) => void;\n  }\n) {\n  const changeMap = new ChangeMap<number, T>();\n  if (!handle) {\n    handle = {\n      add: () => null,\n      remove: () => {},\n      update: () => {},\n    };\n  }\n  let res: GridCell[] = [];\n  return sync({\n    src: {\n      position,\n      opts,\n    },\n    xform: map(({ opts, position }) => {\n      const gridIterator = infiniteGridIterator(position, opts);\n      res.splice(0);\n      for (let cell of gridIterator) {\n        const handler = changeMap.set(cell.id, () => handle.add(cell));\n        handle.update(cell, handler);\n        res.push(cell);\n      }\n      changeMap.next((id, val) => handle.remove(id, val));\n      return res;\n    }),\n  });\n}\n"],
  "mappings": "AAAA;AACA;AACA;AACA;AAGA;AASO,aAAM,uBAAuB,CAClC,UACA,SACG;AACH,QAAM,CAAC,IAAI,MAAM,KAAK;AACtB,QAAM,CAAC,IAAI,MAAM,KAAK;AAEtB,QAAM,KAAK,CAAC,SAAS;AACrB,QAAM,KAAK,CAAC,SAAS;AAGrB,QAAM,QAAQ,KAAK,MAAM,KAAK;AAC9B,QAAM,QAAQ,KAAK,MAAM,KAAK;AAG9B,QAAM,SAAS,KAAK,KAAK,KAAK,MAAM;AACpC,QAAM,SAAS,KAAK,KAAK,KAAK,MAAM;AAEpC,QAAM,MAAM,QAAQ;AACpB,QAAM,MAAM,QAAQ;AAEpB,SAAO,SACL,KACE,IAAI,CAAC,CAAC,GAAG,OAAO;AACd,UAAM,KAAK,IAAI;AACf,UAAM,KAAK,IAAI;AACf,UAAM,KAAK,kBAAkB,GAAG;AAChC,WAAO;AAAA,MACL;AAAA,MACA,MAAM,CAAC,GAAG;AAAA,MACV,OAAO,CAAC,IAAI;AAAA,MACZ,OAAO,CAAC,KAAK,IAAI,KAAK;AAAA;AAAA,OAI5B,QAAQ,OAAO,KAAK,OAAO;AAAA;AASxB,6BACL,UACA,MACA,QAKA;AACA,QAAM,YAAY,IAAI;AACtB,MAAI,CAAC,QAAQ;AACX,aAAS;AAAA,MACP,KAAK,MAAM;AAAA,MACX,QAAQ,MAAM;AAAA;AAAA,MACd,QAAQ,MAAM;AAAA;AAAA;AAAA;AAGlB,MAAI,MAAkB;AACtB,SAAO,KAAK;AAAA,IACV,KAAK;AAAA,MACH;AAAA,MACA;AAAA;AAAA,IAEF,OAAO,IAAI,CAAC,CAAE,aAAM,yBAAe;AACjC,YAAM,eAAe,qBAAqB,WAAU;AACpD,UAAI,OAAO;AACX,eAAS,QAAQ,cAAc;AAC7B,cAAM,UAAU,UAAU,IAAI,KAAK,IAAI,MAAM,OAAO,IAAI;AACxD,eAAO,OAAO,MAAM;AACpB,YAAI,KAAK;AAAA;AAEX,gBAAU,KAAK,CAAC,IAAI,QAAQ,OAAO,OAAO,IAAI;AAC9C,aAAO;AAAA;AAAA;AAAA;",
  "names": []
}
